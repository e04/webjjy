<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        background-color: #222222;
        font-family: "DotGothic16", sans-serif;
        color: white;
      }
      #startOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="startOverlay"></div>

    <div
      style="
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      "
    >
      <div
        style="
          width: 800px;
          display: flex;
          flex-direction: column;
          gap: 1px;
          background-color: #424242;
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            gap: 1px;
            overflow: hidden;
            position: relative;
          "
        >
          <canvas
            id="waterfall"
            width="780"
            height="300"
            style="background-color: black"
          ></canvas>
          <canvas
            id="levelMeter"
            width="20"
            height="300"
            style="background-color: black"
          ></canvas>
          <div
            style="position: absolute; top: 0; left: 8px; font-size: 32px"
          >
            JJY 40.000
          </div>
        </div>

        <canvas
          id="rmsCanvas"
          width="800"
          height="24"
          style="background-color: black"
        ></canvas>

        <div
          id="decodedResult"
          style="
            font-size: 16px;
            height: 24px;
            width: calc(100% - 40px);
            background-color: black;
            overflow: hidden;
            padding-left: 40px;
            line-height: 24px;
          "
        ></div>

        <div
          style="
            display: flex;
            gap: 32px;
            padding: 0 16px;
            background-color: black;
            line-height: 1;
            height: 120px;
          "
        >
          <div>
            <div id="yearDisplay" style="font-size: 64px">----</div>
            <div style="display: flex; gap: 8px; margin-bottom: 8px">
              <div id="mmddDisplay" style="font-size: 32px">--/--</div>
              <div id="dayDisplay" style="font-size: 32px">(---)</div>
            </div>
          </div>
          <div id="timeDisplay" style="font-size: 128px; line-height: 108px">
            --:--
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { fft } from "./fft.js";
      import { calcSpectrum, getColor } from "./util.js";
      import { decode } from "./decode.js";
      import { parse } from "./parse.js";

      document.addEventListener("DOMContentLoaded", () => {
        const startOverlay = document.getElementById("startOverlay");
        const decodedResult = document.getElementById("decodedResult");
        const canvas = document.getElementById("waterfall");
        const ctx = canvas.getContext("2d");
        const levelMeter = document.getElementById("levelMeter");
        const meterCtx = levelMeter.getContext("2d");
        let meterValue = 0;
        const rmsCanvas = document.getElementById("rmsCanvas");
        const rmsCtx = rmsCanvas.getContext("2d");
        const rmsCanvasWidth = rmsCanvas.width;
        const rmsCanvasHeight = rmsCanvas.height;
        let rmsDrawOffset = rmsCanvasWidth - 1;

        let audioContext;
        let microphone;
        let processor;
        let meterProcessor;
        let animationId;
        let waterfall = [];
        let fftSize = 2048;
        let binCount = fftSize / 2;
        let pcmBuffer = new Float32Array(fftSize);
        let pcmBufferOffset = 0;
        let sampledRmsArray = [];

        const minFreq = 35000;
        const maxFreq = 45000;
        let minBin, maxBin, displayBinCount;

        let autoDecodeIntervalId = null;

        const width = canvas.width;
        const height = canvas.height;

        function initFrequencyBins() {
          const sampleRate = 96000;
          const frequencyStep = sampleRate / fftSize;

          minBin = Math.floor(minFreq / frequencyStep);
          maxBin = Math.ceil(maxFreq / frequencyStep);
          displayBinCount = maxBin - minBin;
        }

        function drawWaterfall() {
          ctx.drawImage(
            canvas,
            0,
            0,
            width - 1,
            height,
            1,
            0,
            width - 1,
            height
          );

          if (waterfall.length > 0) {
            const latestData = waterfall[waterfall.length - 1];
            const binHeight = height / displayBinCount;

            for (let i = 0; i < displayBinCount; i++) {
              const spectrumIndex = i + minBin;
              const value = latestData[spectrumIndex];
              const [r, g, b] = getColor(value);
              ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
              ctx.fillRect(0, height - (i + 1) * binHeight, 1, binHeight);
            }
          }
        }

        // レベルメーター描画関数
        function drawLevelMeter() {
          meterCtx.clearRect(0, 0, levelMeter.width, levelMeter.height);
          const percent = meterValue;
          const barHeight = Math.round(levelMeter.height * percent);
          meterCtx.fillStyle = percent > 0.3 ? "#0f0" : "#888";
          meterCtx.fillRect(
            0,
            levelMeter.height - barHeight,
            levelMeter.width,
            barHeight
          );
        }

        function drawRmsCanvas(rms) {
          rmsCtx.drawImage(
            rmsCanvas,
            0,
            0,
            rmsCanvasWidth - 1,
            rmsCanvasHeight,
            1,
            0,
            rmsCanvasWidth - 1,
            rmsCanvasHeight
          );
          const v = Math.max(0, Math.min(1, rms));
          const barHeight = Math.round(v * rmsCanvasHeight);

          rmsCtx.fillStyle = "black";
          rmsCtx.fillRect(0, 0, 1, rmsCanvasHeight);

          rmsCtx.fillStyle = "white";
          rmsCtx.fillRect(0, rmsCanvasHeight - barHeight, 1, barHeight);
        }

        function runAutoDecode() {
          if (sampledRmsArray.length > 0) {
            const decodedData = decode(sampledRmsArray);

            const parsed = parse(decodedData.slice(-120));

            const timeDisplay = document.getElementById("timeDisplay");
            const yearDisplay = document.getElementById("yearDisplay");
            const mmddDisplay = document.getElementById("mmddDisplay");

            if (parsed && !parsed.error) {
              if (parsed.hour !== undefined && parsed.minute !== undefined) {
                const hour = String(parsed.hour).padStart(2, "0");
                const minute = String(parsed.minute).padStart(2, "0");
                timeDisplay.textContent = `${hour}:${minute}`;
              }

              if (parsed.year !== undefined && !parsed.special) {
                yearDisplay.textContent = parsed.year;
              }

              if (parsed.month !== undefined && parsed.day !== undefined) {
                mmddDisplay.textContent = `${parsed.month}/${parsed.day}`;
              }

              if (parsed.dayOfWeek !== undefined) {
                const dayDisplay = document.getElementById("dayDisplay");
                dayDisplay.textContent = `(${parsed.dayOfWeek})`;
              }
            }

            const result = decodedData
              .toReversed()
              .map((char) => {
                switch (char) {
                  case "M":
                    return `<span style="display: inline-block;background-color: #2E7D32;width: 30px;text-align: center;">${char}</span>`;
                  case "0":
                    return `<span style="display: inline-block;width: 30px;text-align: center;">${char}</span>`;
                  case "1":
                    return `<span style="display: inline-block;background-color: #FFFFFF;color: black;width: 30px;text-align: center;">${char}</span>`;
                }
              })
              .join("");

            decodedResult.innerHTML = result;
          }
        }

        autoDecodeIntervalId = setInterval(runAutoDecode, 1000);

        function processAudioFrame() {
          if (pcmBufferOffset === fftSize) {
            const spectrum = calcSpectrum(pcmBuffer, fft);
            waterfall.push(spectrum);
            if (waterfall.length > width) waterfall.shift();
            drawWaterfall();
            pcmBufferOffset = 0;
          }
          animationId = requestAnimationFrame(processAudioFrame);
        }

        function startCapture() {
          if (startOverlay) {
            startOverlay.style.display = "none";
          }

          navigator.mediaDevices
            .getUserMedia({
              audio: {
                sampleRate: 96000,
                channelCount: 1,
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
              },
            })
            .then((stream) => {
              audioContext = new window.AudioContext({ sampleRate: 96000 });
              microphone = audioContext.createMediaStreamSource(stream);
              processor = audioContext.createScriptProcessor(fftSize, 1, 1);
              // 800Hz中心のバンドパスフィルター
              const bandpass = audioContext.createBiquadFilter();
              bandpass.type = "bandpass";
              bandpass.frequency.value = 800;
              bandpass.Q.value = 10;
              let mixerPhase = 0;
              const mixerFreq = 40800;
              const sampleRate = audioContext.sampleRate;
              microphone.connect(processor);
              processor.connect(bandpass);
              meterProcessor = audioContext.createScriptProcessor(256, 1, 1);
              bandpass.connect(meterProcessor);
              meterProcessor.connect(audioContext.destination);
              const sampleProcessorBufferSize = 4096;
              const sampleProcessor = audioContext.createScriptProcessor(
                sampleProcessorBufferSize,
                1,
                1
              );
              let rmsSum = 0;
              let rmsCount = 0;
              let samples = Math.round(sampleRate / 32);
              let sampleCounter = 0;
              let lastLogTime = audioContext.currentTime;
              bandpass.connect(sampleProcessor);
              sampleProcessor.connect(audioContext.destination);
              sampleProcessor.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                for (let i = 0; i < input.length; i++) {
                  rmsSum += input[i] * input[i];
                  rmsCount++;
                  sampleCounter++;
                  if (sampleCounter >= samples) {
                    const rms = Math.sqrt(rmsSum / rmsCount);
                    sampledRmsArray.push(rms);
                    drawRmsCanvas(rms); // ここで描画
                    rmsSum = 0;
                    rmsCount = 0;
                    sampleCounter = 0;
                  }
                }
              };
              meterProcessor.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < input.length; i++) {
                  sum += input[i] * input[i];
                }
                const rms = Math.sqrt(sum / input.length);
                meterValue = Math.min(1, rms);
                drawLevelMeter();
              };
              bandpass.connect(audioContext.destination);
              waterfall = [];
              pcmBuffer = new Float32Array(fftSize);
              pcmBufferOffset = 0;
              rmsDrawOffset = rmsCanvasWidth - 1;
              ctx.fillStyle = "black";
              ctx.fillRect(0, 0, width, height);
              processor.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                const output = e.outputBuffer.getChannelData(0);
                let remain = fftSize - pcmBufferOffset;
                if (input.length <= remain) {
                  pcmBuffer.set(input, pcmBufferOffset);
                  pcmBufferOffset += input.length;
                } else {
                  pcmBuffer.set(input.subarray(0, remain), pcmBufferOffset);
                  pcmBufferOffset = fftSize;
                }
                for (let i = 0; i < input.length; i++) {
                  const gain = 500;
                  const mixer = Math.sin(2 * Math.PI * mixerPhase);
                  output[i] = input[i] * gain * mixer;
                  mixerPhase += mixerFreq / sampleRate;
                  if (mixerPhase >= 1) mixerPhase -= 1;
                }
              };
              initFrequencyBins();
              processAudioFrame();
            });
        }

        // オーバーレイクリックで開始
        if (startOverlay) {
          startOverlay.addEventListener("click", startCapture);
        }
      });
    </script>
  </body>
</html>
